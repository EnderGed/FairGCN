# Libraries
from math import pi

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import pandas as pd
import numpy as np

# Set data
from matplotlib.lines import Line2D

from consts import RESULTS_PATH, PLOT_PATH
from gen_utils import deprecated

colors = {'base': mcolors.TABLEAU_COLORS['tab:brown'],
          'Ad': mcolors.TABLEAU_COLORS['tab:orange'],   # color for Adeversarial Debiasing (FairGNN '2020)
          'Fil': mcolors.TABLEAU_COLORS['tab:pink'],
          'Flpar': mcolors.TABLEAU_COLORS['tab:green'],
          'Fleoo': mcolors.TABLEAU_COLORS['tab:olive'],
          'Ew': mcolors.TABLEAU_COLORS['tab:red'],
          'Ep': mcolors.TABLEAU_COLORS['tab:cyan'],
          'EwAd': mcolors.TABLEAU_COLORS['tab:purple'],
          'EwFlpar': mcolors.TABLEAU_COLORS['tab:blue'],
          }

fontsizes = {'title': 16}

my_dpi = 96
fig_width = 900 / my_dpi

plot_names = {'priv_leak': 'attribute inference',
              'mino_priv_leak': 'minority attr_inf',
              'majo_priv_leak': 'majority attr_inf',
              'mia_acc': 'membership inference',
              'mino_mia_acc': 'minority mia',
              'majo_mia_acc': 'majority mia',
              'simple_mia': 'simple_mia',
              'fair_leak': 'invariance',
              'mino_fair_leak': 'minority invariance',
              'majo_fair_leak': 'majority invariance',
              'par': 'statistical parity',
              'eoo': 'equality of opportunity',
              'test_acc': 'accuracy'}


@deprecated
def make_single_spider(df, model, plot_no, categories, max_vals):
    # number of variable
    num_cat = len(categories)

    # What will be the angle of each axis in the plot? (we divide the plot / number of variable)
    angles = [n / float(num_cat) * 2 * pi for n in range(num_cat)]
    angles += angles[:1]

    # Initialise the spider plot
    ax = plt.subplot(1, 3, plot_no + 1, polar=True, )

    # If you want the first axis to be on top:
    ax.set_theta_offset(pi / 2)
    ax.set_theta_direction(-1)

    # Draw one axe per variable + add labels labels yet
    plt.xticks(angles[:-1], categories, color='grey', size=8)

    # Draw ylabels
    ax.set_rlabel_position(0)
    ticks = [i / 4. for i in range(1, 5)]
    plt.yticks(ticks, [str(i) for i in ticks], color="grey", size=7)
    plt.ylim(0, 1)

    # Ind1
    values = df.loc[df.emb_net == model, categories].values.flatten().tolist()
    values += values[:1]
    ax.plot(angles, values, color=colors['base'], linewidth=2, linestyle='solid')
    ax.fill(angles, values, color=colors['base'], alpha=0.4)

    # Ind2
    values = df.loc[df.emb_net == "Ad" + model, categories].values.flatten().tolist()
    values += values[:1]
    ax.plot(angles, values, color=colors['ad'], linewidth=1, linestyle='solid')
    ax.fill(angles, values, color=colors['ad'], alpha=0.4)

    # Add a title
    plt.title(model, size=11, y=1.1)


@deprecated
def plot_dataset_measures(ds_name='nba', emb_name='opt'):
    """
        Use a file generated by `scripts.combine_leak_performance_data` to plot the results for a single dataset
        in a spider plot form.
        :return:
    """
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.ds_name == ds_name].loc[comb.emb_name == emb_name]
    comb.par = comb.par.apply(abs)
    comb.eoo = comb.eoo.apply(abs)

    # select categories and rescale data
    categories = ['train_acc', 'test_acc', 'priv_leak', 'fair_leak', 'eoo', 'par']
    max_vals = [1., 1., 1., 1., 0.4, 0.4]
    # if we had 4 bins for privacy attack, rescale priv_leak
    if comb['bins'].values[0] == 4:
        max_vals[2] = 0.5
    # rescale values according to max_vals
    for cat, max_val in zip(categories, max_vals):
        comb[cat] = comb[cat].apply(lambda x: x/max_val)

    # initialize the figure
    fig = plt.figure(figsize=(fig_width, 400 / my_dpi), dpi=my_dpi)
    fig.suptitle('{}_{}'.format(ds_name, emb_name), size=14)
    legend_elements = [Line2D([0], [0], color=colors['base'], lw=4, label='Base'),
                       Line2D([0], [0], color=colors['ad'], lw=4, label='Ad')]

    fig.legend(handles=legend_elements, loc='lower center', ncol=2)

    for plot_no, model in enumerate(['Kipf', 'Sage', 'Gat']):
        if comb.loc[comb.emb_net == model].shape[0] > 0:
            make_single_spider(comb, model, plot_no, categories, max_vals)
    plt.savefig(fname='{}{}_{}.png'.format(PLOT_PATH, ds_name, emb_name), dpi=my_dpi, format='png')


def plot_alpha_beta_importance(ds_name='nba', emb_net='Kipf', hyper_name='opt', fair_net='Ad',
                               alphas_sub=None, betas_sub=None):
    """
    Plot 7 subplots for utility, privacy, mia, simple_mia, fair_leak, par, eoo on y axis, and different alphas on x axis
    For each beta make a separate line on the same plot, treat Fleoo and Flpar as different betas (plot together)

    :param ds_name:
    :param emb_net:
    :param hyper_name:
    :param fair_net:
    :param alphas_sub: plot only a subset of alphas, None to plot all alphas
    :param betas_sub: plot only a subset of betas, None to plot all betas
    :return:
    """
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    # comb.par = comb.par.apply(abs)
    # comb.eoo = comb.eoo.apply(abs)
    comb.alpha = comb.alpha.apply(float)
    comb.beta = comb.beta.apply(float)

    # Because Ad is the only method that has many alpha values and few beta, we just switch them for simple plotting
    if fair_net == 'Ad':
        tmp = comb.alpha.copy()
        comb.alpha = comb.beta
        comb.beta = tmp
        # comb.alpha, comb.beta = comb.beta, comb.alpha
        alphas_sub, betas_sub = betas_sub, alphas_sub

    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name].loc[comb.emb_net == emb_net]
    comb_baseline = comb.loc[comb.fair_net == 'base']

    # Treat Fleoo and Flpar as different betas
    if fair_net == 'Fl':
        comb = comb.loc[comb.fair_net.isin(['Fleoo', 'Flpar'])]
        comb.beta = comb.fair_net.apply(lambda x: x[-3:])
    else:
        comb = comb.loc[comb.fair_net == fair_net]

    plt.clf()
    fig = plt.figure(figsize=(fig_width, 500 / my_dpi), dpi=my_dpi)
    fig.suptitle('{} {}{}'.format(ds_name, fair_net, emb_net), fontsize=fontsizes['title'])
    axs = fig.subplots(2, 4, sharex=True)

    alphas = sorted([alpha for alpha in comb.alpha.unique() if alphas_sub is None or alpha in alphas_sub])
    betas = sorted([beta for beta in comb.beta.unique() if betas_sub is None or beta in betas_sub])

    aranged = np.arange(len(alphas))

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]

        # plot the baseline
        unfair_met = comb_baseline[metric].item()
        unfair_min = unfair_met - comb_baseline[metric + '_min'].item()
        unfair_max = comb_baseline[metric + '_max'].item() - unfair_met
        # ax.plot([aranged[0], aranged[-1]], [unfair_met] * 2, label=emb_net, linestyle='--', color='gray')
        ax.errorbar([aranged[0]-0.1, aranged[-1]-0.1], [unfair_met] * 2, yerr=([unfair_min] * 2, [unfair_max] * 2),
                    label=emb_net, linestyle='--', color='grey', elinewidth=0.4, fmt='.')

        for i, beta in enumerate(betas):
            # if len(alphas) > 1:
            subset = comb.loc[comb.beta == beta].loc[comb.alpha.isin(alphas)].sort_values('alpha')
            y = subset[metric].values
            y_min = y - subset[metric + '_min'].values
            y_max = subset[metric + '_max'].values - y
            # ax.plot(aranged, y, label=str(beta))
            ax.errorbar(aranged + i/10, y, yerr=(y_min, y_max), label=str(beta), elinewidth=0.4, fmt='.')
            # else:
            #     assert fair_net == 'Ep'
            #     fair_met = comb[metric].item()
            #
            #     ax.plot([aranged[0], aranged[-1]], [fair_met] * 2, label=str(beta), linestyle='--')
        # make ticks
        ax.xaxis.set_ticks(aranged)    # set the ticks to be arranged
        ax.xaxis.set_ticklabels(alphas)  # change the ticks' names to alphas
        ax.tick_params('x', labelrotation=45)
        ax.set_title(plot_names[metric])
    plt.xticks(aranged, alphas, rotation=45)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'priv_leak')
    plot_single_metric(0, 2, 'mia_acc')
    plot_single_metric(0, 3, 'simple_mia')
    plot_single_metric(1, 0, 'fair_leak')
    plot_single_metric(1, 1, 'par')
    plot_single_metric(1, 2, 'eoo')
    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}v3ab_{}_{}{}.png'.format(PLOT_PATH, ds_name, fair_net, emb_net), dpi=my_dpi, format='png')
    plt.close()


def plot_utiliy_fairnes_comp(ds_name='nba', hyper_name='opt', emb_net='Kipf', errorbars=False, acc_drop=0.,
                             fair_nets=None):
    """
    Plot 6 subplots of priv, mia, simple_mia, fair_leak, par, eoo on y axis and utility on x axis
    Each fairnes approach is represented by a single line on the same subplots
    :param ds_name:
    :param hyper_name:
    :param emb_net:
    :param errorbars: should error bars be plotted
    :param acc_drop: all methods worse then `acc_drop` * base_acc will be dropped from plotting
    :param fair_nets: Fair nets to plot, all if None
    :return:
    """
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    # comb.par = comb.par.apply(abs)
    # comb.eoo = comb.eoo.apply(abs)
    # comb.alpha = comb.alpha.apply(float)
    comb.beta = comb.beta.apply(float)

    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name].loc[comb.emb_net == emb_net]
    base_acc = comb.loc[comb.fair_net == 'base']['test_acc'].item()
    comb = comb.loc[comb.test_acc > base_acc * acc_drop]

    fair_nets_subset_name = 'chosen'
    if fair_nets is None:
        fair_nets_subset_name = 'all'
        fair_nets = ['Ad', 'Fil', 'Ew', 'Flpar', 'Fleoo', 'base', 'Ep']

    plt.clf()
    fig = plt.figure(figsize=(fig_width, 500 / my_dpi), dpi=my_dpi)
    fig.suptitle('Utility of {} on {}'.format(emb_net, ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(2, 3, sharex=True)

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]

        for fair_net in fair_nets:
            tmp_comb = comb.loc[comb.fair_net == fair_net].sort_values('test_acc')
            x = tmp_comb['test_acc'].values
            y = tmp_comb[metric].values
            if errorbars:
                x_min = x - tmp_comb['test_acc_min'].values
                x_max = tmp_comb['test_acc_max'].values - x
                y_min = y - tmp_comb[metric + '_min'].values
                y_max = tmp_comb[metric + '_max'].values - y
                if fair_net in ['base', 'Ep']:
                    ax.errorbar(x, y, xerr=(x_min, x_max), yerr=(y_min, y_max), label=fair_net, marker='x', linestyle='',
                                markersize=10., elinewidth=0.4, alpha=0.7)
                else:
                    ax.errorbar(x, y, xerr=(x_min, x_max), yerr=(y_min, y_max), label=fair_net, marker='.', linestyle='',
                                elinewidth=0.4)
            else:
                if fair_net in ['base', 'Ep']:
                    ax.scatter(x, y, label=fair_net, marker='x', s=70., linewidth=3.)
                else:
                    ax.scatter(x, y, label=fair_net, marker='.', alpha=0.6)
        ax.set_title(plot_names[metric])
    plot_single_metric(0, 0, 'priv_leak')
    plot_single_metric(0, 1, 'mia_acc')
    plot_single_metric(0, 2, 'simple_mia')
    plot_single_metric(1, 0, 'fair_leak')
    plot_single_metric(1, 1, 'par')
    plot_single_metric(1, 2, 'eoo')
    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower center', ncol=7, bbox_to_anchor=(0.5, 0))
    plt.tight_layout()
    plt.savefig(fname='{}{}_utility_{}_{}.png'.format(PLOT_PATH, fair_nets_subset_name, ds_name, emb_net),
                dpi=my_dpi, format='png')


def plot_utiliy_fairnes_comp_3_best(ds_name='nba', hyper_name='opt', emb_net='Kipf', errorbars=False, acc_drop=0.,
                                    fair_nets=None):
    """
    Plot 3 subplots of priv, par, eoo on y axis and utility on x axis
    Each fairnes approach is represented by a single line on the same subplots
    :param ds_name:
    :param hyper_name:
    :param emb_net:
    :param errorbars: should error bars be plotted
    :param acc_drop: all methods worse then `acc_drop` * base_acc will be dropped from plotting
    :param fair_nets: Fair nets to plot, all if None
    :return:
    """
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    best = pd.read_feather('{}best.ftr'.format(RESULTS_PATH))
    # comb.par = comb.par.apply(abs)
    # comb.eoo = comb.eoo.apply(abs)
    # comb.alpha = comb.alpha.apply(float)
    comb.beta = comb.beta.apply(float)

    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name].loc[comb.emb_net == emb_net]
    best = best.loc[best.ds_name == ds_name].loc[best.hyper_name == hyper_name].loc[best.emb_net == emb_net]
    base_acc = comb.loc[comb.fair_net == 'base']['test_acc'].item()
    comb = comb.loc[comb.test_acc > base_acc * acc_drop]

    fair_nets_subset_name = 'chosen'
    if fair_nets is None:
        fair_nets_subset_name = 'all'
        fair_nets = ['base', 'Ad', 'Fil', 'Ew', 'Flpar', 'Fleoo', 'Ep']

    plt.clf()
    fig = plt.figure(figsize=(fig_width, 250 / my_dpi), dpi=my_dpi)
    fig.suptitle('Utility of {} on {}'.format(emb_net, ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(1, 3)

    def plot_single_metric(subplot_x, metric):
        ax = axs[subplot_x]

        # for fair_net in fair_nets:
        #     tmp_comb = comb.loc[comb.fair_net == fair_net].sort_values('test_acc')
        #     x = tmp_comb['test_acc'].values
        #     y = tmp_comb[metric].values
        #     if errorbars:
        #         x_min = x - tmp_comb['test_acc_min'].values
        #         x_max = tmp_comb['test_acc_max'].values - x
        #         y_min = y - tmp_comb[metric + '_min'].values
        #         y_max = tmp_comb[metric + '_max'].values - y
        #         if fair_net in ['base', 'Ep']:
        #             ax.errorbar(x, y, xerr=(x_min, x_max), yerr=(y_min, y_max), label=fair_net, marker='x', linestyle='',
        #                         markersize=10., elinewidth=0.4, alpha=0.7)
        #         else:
        #             ax.errorbar(x, y, xerr=(x_min, x_max), yerr=(y_min, y_max), label=fair_net, marker='.', linestyle='',
        #                         elinewidth=0.4)
        #     else:
        #         if fair_net in ['base', 'Ep']:
        #             ax.scatter(x, y, color=colors[fair_net], marker='x', s=70., linewidth=3., alpha=0.3)
        #         else:
        #             ax.scatter(x, y, color=colors[fair_net], marker='.', alpha=0.3)

        for fair_net in fair_nets:
            tmp_best = best.loc[best.fair_net == fair_net]
            x = tmp_best['test_acc'].values
            y = tmp_best[metric].values
            if fair_net in ['base', 'Ep']:
                ax.scatter(x, y, color=colors[fair_net], label=fair_net, marker='x', s=70., linewidth=1.5)
            else:
                ax.scatter(x, y, color=colors[fair_net], label=fair_net, edgecolors='black', marker='.', s=70.,
                           linewidth=.5)

        ax.set_title(plot_names[metric])
    plot_single_metric(0, 'priv_leak')
    plot_single_metric(1, 'par')
    plot_single_metric(2, 'eoo')
    handles, labels = axs[0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower center', ncol=7, bbox_to_anchor=(0.5, 0))
    plt.tight_layout()
    plt.savefig(fname='{}{}_utility3_{}_{}.png'.format(PLOT_PATH, fair_nets_subset_name, ds_name, emb_net),
                dpi=my_dpi, format='png')


def plot_fairness_privacy(ds_name='nba', hyper_name='opt', emb_net='Kipf', fair_nets=None):
    """
    Make 2 subplots, par, eoo on the y axis and attribute inference on the x axis
    :param ds_name:
    :param hyper_name:
    :param emb_net:
    :param fair_nets: Fair nets to plot, all if None
    :return:
    """
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name].loc[comb.emb_net == emb_net]
    fair_nets_subset_name = 'chosen'
    if fair_nets is None:
        fair_nets_subset_name = 'all'
        fair_nets = ['Ad', 'Fil', 'Ew', 'Flpar', 'Fleoo', 'base', 'Ep']

    plt.clf()
    fig = plt.figure(figsize=(fig_width, 300 / my_dpi), dpi=my_dpi)
    fig.suptitle('Privacy to Fairness of {} on {}'.format(emb_net, ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(1, 2)

    def plot_single_metric(subplot_x, metric):
        ax = axs[subplot_x]
        for fair_net in fair_nets:
            tmp_comb = comb.loc[comb.fair_net == fair_net]
            x = tmp_comb['priv_leak']
            y = tmp_comb[metric]
            if fair_net in ['base', 'Ep']:
                ax.scatter(x, y, marker='x', s=70., linewidth=3.)
            else:
                ax.scatter(x, y, marker='.', edgecolor='none', alpha=0.6)
        ax.set_title(plot_names[metric])
    plot_single_metric(0, 'par')
    plot_single_metric(1, 'eoo')
    handles, labels = axs[0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower center', ncol=7, bbox_to_anchor=(0.5, 0))
    plt.tight_layout()
    plt.savefig(fname='{}{}_priv_fairness_{}_{}'.format(PLOT_PATH, fair_nets_subset_name, ds_name, emb_net),
                dpi=my_dpi, format='png')


def plot_base_performance():
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.hyper_name == 'opt'].loc[comb.fair_net == 'base'].sort_values(by='ds_name')

    plt.clf()
    fig = plt.figure(figsize=(fig_width, 500 / my_dpi), dpi=my_dpi)
    fig.suptitle('Base GNNs performance', fontsize=fontsizes['title'])
    axs = fig.subplots(2, 4, sharex=True)

    gnns = ['Kipf', 'Sage', 'Gat']
    datasets = list(comb.ds_name.unique())

    aranged = np.arange(len(datasets))

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        for i, gnn in enumerate(gnns):
            subset = comb.loc[comb.emb_net == gnn]
            y = subset[metric].values
            y_min = y - subset[metric + '_min'].values
            y_max = subset[metric + '_max'].values - y
            ax.errorbar(aranged + i/10 - .05 * (len(gnns) - 1), y, yerr=(y_min, y_max), label=str(gnn),
                        elinewidth=0.4, fmt='.')
            #     ax.plot([aranged[0], aranged[-1]], [fair_met] * 2, label=str(beta), linestyle='--')
        # make ticks
        ax.xaxis.set_ticks(aranged)    # set the ticks to be arranged
        ax.xaxis.set_ticklabels(datasets)  # change the ticks' names to alphas
        ax.tick_params('x')  # , labelrotation=45)
        ax.set_title(plot_names[metric])
    plt.xticks(aranged, datasets)  # , rotation=45)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'priv_leak')
    plot_single_metric(0, 2, 'mia_acc')
    plot_single_metric(0, 3, 'simple_mia')
    plot_single_metric(1, 0, 'fair_leak')
    plot_single_metric(1, 1, 'par')
    plot_single_metric(1, 2, 'eoo')
    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}base_performance.png'.format(PLOT_PATH), dpi=my_dpi, format='png')
    plt.close()


def plot_priv_lambda_importance(ds_name='nba'):
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    # currently combined only has best results for fairness
    # best = pd.read_feather('{}best.ftr'.format(RESULTS_PATH))
    best = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    fair_subset = [('Cens', 'base'), ('CensAd', 'Ad'), ('CensFlpar', 'Flpar'), ('CensEw', 'Ew'), ('CensEwAd', 'EwAd'),
                  ('CensEwFlpar', 'EwFlpar')]
    comb = comb.loc[comb.ds_name == ds_name].sort_values(by='priv_lambda', ascending=True)
    best = best.loc[best.ds_name == ds_name]
    base_nets = [('Kipf', 'solid'), ('Sage', 'dashed')]
    plt.clf()
    fig = plt.figure(figsize=(fig_width, 1200 / my_dpi), dpi=my_dpi)
    fig.suptitle('Lambda effect on {}'.format(ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(4, 3, sharex=True)
    x_labels = [0] + comb.priv_lambda.unique()
    xs = np.arange(len(x_labels))

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        for priv_model, fair_model in fair_subset:
            for model_name, line_style in base_nets:
                tmp_comb = comb.loc[comb.fair_net == priv_model].loc[comb.emb_net == model_name]
                lambdas = [0] + tmp_comb.priv_lambda.values
                base_y = best.loc[best.fair_net == fair_model].loc[best.emb_net == model_name][metric].item()
                ys = tmp_comb[metric].values
                ys = np.insert(ys, 0, base_y, axis=0)
                # ys = np.concatenate((base_y + tmp_comb[metric].values))
                ax.plot(xs, ys, linestyle=line_style, color=colors[fair_model], label=priv_model + model_name)
        if subplot_y == 3:
            ax.set_xlabel('priv_lambda')
        ax.set_ylabel(plot_names[metric])
        ax.xaxis.set_ticks(xs)
        ax.xaxis.set_ticklabels(x_labels)
    plt.xticks(xs, x_labels, rotation=45)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'par')
    plot_single_metric(0, 2, 'eoo')
    plot_single_metric(1, 0, 'priv_leak')
    plot_single_metric(1, 1, 'mino_priv_leak')
    plot_single_metric(1, 2, 'majo_priv_leak')
    plot_single_metric(2, 0, 'mia_acc')
    plot_single_metric(2, 1, 'mino_mia_acc')
    plot_single_metric(2, 2, 'majo_mia_acc')
    plot_single_metric(3, 0, 'fair_leak')
    plot_single_metric(3, 1, 'mino_fair_leak')
    plot_single_metric(3, 2, 'majo_fair_leak')

    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}lambda_importance_{}.png'.format(PLOT_PATH, ds_name), dpi=my_dpi, format='png')
    plt.close()


def plot_mino_majo_privacy_influence(ds_name='nba', fair_net='Ad'):
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb.alpha = comb.alpha.apply(float)
    comb.beta = comb.beta.apply(float)

    # Because Ad is the only method that has many alpha values and few beta, we just switch them for simple plotting
    if fair_net == 'Ad':
        tmp = comb.alpha.copy()
        comb.alpha = comb.beta.copy()
        comb.beta = tmp

    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == 'opt']
    comb_baseline = comb.loc[comb.fair_net == 'base']
    comb = comb.loc[comb.fair_net == fair_net]

    alphas = sorted([alpha for alpha in comb.alpha.unique()])
    betas = sorted([beta for beta in comb.beta.unique()])

    aranged = np.arange(len(alphas))


    base_nets = [('Kipf', 'solid'), ('Sage', 'dashed')]
    plt.clf()
    fig = plt.figure(figsize=(fig_width, 1200 / my_dpi), dpi=my_dpi)
    fig.suptitle('Lambda effect on {}'.format(ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(4, 3, sharex=True)

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        for emb_net, linestyle in base_nets:
            comb_tmp = comb.loc[comb.emb_net == emb_net]
            comb_baseline_tmp = comb_baseline.loc[comb_baseline.emb_net == emb_net]
            # plot the baseline
            unfair_met = comb_baseline_tmp[metric].item()
            unfair_min = unfair_met - comb_baseline_tmp[metric + '_min'].item()
            unfair_max = comb_baseline_tmp[metric + '_max'].item() - unfair_met
            # ax.plot([aranged[0], aranged[-1]], [unfair_met] * 2, label=emb_net, linestyle='--', color='gray')
            ax.errorbar([aranged[0]-0.1, aranged[-1]-0.1], [unfair_met] * 2, yerr=([unfair_min] * 2, [unfair_max] * 2),
                        label=emb_net, linestyle=linestyle, color='grey', elinewidth=0.4, fmt='.')

            for i, beta in enumerate(betas):
                subset = comb_tmp.loc[comb_tmp.beta == beta].sort_values('alpha')
                y = subset[metric].values
                y_min = y - subset[metric + '_min'].values
                y_max = subset[metric + '_max'].values - y
                ax.errorbar(aranged + i/10, y, yerr=(y_min, y_max), label=str(beta), elinewidth=0.4, fmt='.',
                            linestyle=linestyle)

        if subplot_y == 3:
            ax.set_xlabel('alpha')
        ax.set_ylabel(plot_names[metric])
        ax.xaxis.set_ticks(aranged)
        ax.xaxis.set_ticklabels(alphas)

    plt.xticks(aranged, alphas, rotation=45)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'par')
    plot_single_metric(0, 2, 'eoo')
    plot_single_metric(1, 0, 'priv_leak')
    plot_single_metric(1, 1, 'mino_priv_leak')
    plot_single_metric(1, 2, 'majo_priv_leak')
    plot_single_metric(2, 0, 'mia_acc')
    plot_single_metric(2, 1, 'mino_mia_acc')
    plot_single_metric(2, 2, 'majo_mia_acc')
    plot_single_metric(3, 0, 'fair_leak')
    plot_single_metric(3, 1, 'mino_fair_leak')
    plot_single_metric(3, 2, 'majo_fair_leak')

    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}fairness_on_group_privacy_of_{}_on_{}.png'.format(PLOT_PATH, fair_net, ds_name), dpi=my_dpi,
                format='png')
    plt.close()


def plot_overtrained_results(ds_name='nba'):
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.ds_name == ds_name]
    base_nets = ['Kipf', 'Sage', 'Gin', 'Gat']
    plt.clf()
    fig = plt.figure(figsize=(fig_width, 900 / my_dpi), dpi=my_dpi)
    fig.suptitle('Overtrained network {}'.format(ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(3, 3, sharex='all', sharey='row')
    x_labels = base_nets
    xs = np.arange(4)

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        for i, hyper_name, pretty_name in [(0, '64Noval', 'transductive'), (1, '64NovalInd', 'inductive')]:
            tmp_comb = comb.loc[comb.hyper_name == hyper_name].set_index('emb_net').reindex(base_nets)
            ax.scatter(xs, tmp_comb[metric].values, label=pretty_name)
            ys = tmp_comb[metric].values
            ys_min = ys - tmp_comb[metric + '_min'].values
            ys_max = tmp_comb[metric + '_max'].values - ys
            ax.errorbar(xs + i/10., ys, yerr=(ys_min, ys_max), label=pretty_name, fmt='o')
        ax.set_ylabel(plot_names[metric])
        ax.xaxis.set_ticks(xs)
        ax.xaxis.set_ticklabels(x_labels)
    plt.xticks(xs, x_labels) #, rotation=45)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'par')
    plot_single_metric(0, 2, 'eoo')
    plot_single_metric(1, 0, 'priv_leak')
    plot_single_metric(1, 1, 'mino_priv_leak')
    plot_single_metric(1, 2, 'majo_priv_leak')
    plot_single_metric(2, 0, 'mia_acc')
    plot_single_metric(2, 1, 'mino_mia_acc')
    plot_single_metric(2, 2, 'majo_mia_acc')

    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}Overtrained_networks_{}.png'.format(PLOT_PATH, ds_name), dpi=my_dpi, format='png')
    plt.close()


def plot_opt_with_64_results(ds_name='nba', model_name='Kipf', fair_net='Ad'):
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.ds_name == ds_name].loc[comb.emb_net == model_name]
    comb.alpha = comb.alpha.apply(float)
    comb.beta = comb.beta.apply(float)

    # Because Ad is the only method that has many alpha values and few beta, we just switch them for simple plotting
    if fair_net == 'Ad':
        tmp = comb.alpha.copy()
        comb.alpha = comb.beta.copy()
        comb.beta = tmp

    comb_baseline = comb.loc[comb.fair_net == 'base']
    comb = comb.loc[comb.fair_net == fair_net].sort_values(by=['beta', 'alpha'])


    xs = np.arange(comb.loc[comb.hyper_name == 'opt'].shape[0])

    plt.clf()
    fig = plt.figure(figsize=(fig_width, 900 / my_dpi), dpi=my_dpi)
    fig.suptitle('Hyperparameter comparison for {}{} on {}'.format(fair_net, model_name, ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(3, 3, sharex='all', sharey='row')
    # x_labels = base_nets
    # xs = np.arange(4)

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        for i, hyper_name, pretty_name, color in [(-1, 'opt', 'optimized', 'orange'), (0, '64Noval', 'transductive', 'blue'), (1, '64NovalInd', 'inductive', 'green')]:
            tmp_comb = comb.loc[comb.hyper_name == hyper_name]
            tmp_comb_baseline = comb_baseline.loc[comb_baseline.hyper_name == hyper_name]
            # plot the baseline
            unfair_met = tmp_comb_baseline[metric].item()
            ax.plot([xs[0], xs[-1]], [unfair_met] * 2, label=pretty_name + ' base', linestyle='--', color=color, alpha=0.7)
            if tmp_comb.shape[0] > 0:
                ax.plot(xs, tmp_comb[metric].values, label=pretty_name, color=color)
        ax.set_ylabel(plot_names[metric])
        ax.xaxis.set_ticks(xs)
        # ax.xaxis.set_ticklabels(x_labels)
    # plt.xticks(xs, x_labels) #, rotation=45)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'par')
    plot_single_metric(0, 2, 'eoo')
    plot_single_metric(1, 0, 'priv_leak')
    plot_single_metric(1, 1, 'mino_priv_leak')
    plot_single_metric(1, 2, 'majo_priv_leak')
    plot_single_metric(2, 0, 'mia_acc')
    plot_single_metric(2, 1, 'mino_mia_acc')
    plot_single_metric(2, 2, 'majo_mia_acc')

    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}Hyperparams_comparison_{}_{}{}.png'.format(PLOT_PATH, ds_name, fair_net, model_name), dpi=my_dpi, format='png')
    plt.close()


@deprecated
def plot_beta_importance(ds_name='nba', hyper_name='opt', alpha=1., fair_method='Ad'):
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name].loc[
        (comb.alpha == alpha) | (~ comb.emb_net.str.contains(fair_method))]
    comb.par = comb.par.apply(abs)
    comb.eoo = comb.eoo.apply(abs)
    comb.beta = comb.beta.apply(float)
    plt.clf()
    fig = plt.figure(figsize=(fig_width, 500 / my_dpi), dpi=my_dpi)
    fig.suptitle('{} beta effect on {}'.format(fair_method, ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(2, 3, sharex=True)
    prop_cycle = plt.rcParams['axes.prop_cycle']
    std_colors = prop_cycle.by_key()['color']

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        min_beta, max_beta = comb.loc[comb.alpha == alpha].beta.min(), comb.beta.max()
        for i, model in enumerate(['Kipf', 'Sage', 'Gat']):
            ax.plot('beta', metric, data=comb.loc[comb.emb_net == 'Ad{}'.format(model)].sort_values('beta'),
                    label='Ad{}'.format(model), linestyle='-', color=std_colors[i])
            # plot the (unfair) baselines
            unfair_met = comb.loc[comb.emb_net == model][metric].item()
            ax.plot([min_beta, max_beta], [unfair_met] * 2, linestyle='--', color=std_colors[i])
        # make ticks
        # ax.tick_params('x', labelrotation=45)
        # ax.set_title(metric)
        ax.set_xlabel('beta')
        ax.set_ylabel(metric)
    plot_single_metric(0, 0, 'test_acc')
    plot_single_metric(0, 1, 'priv_leak')
    plot_single_metric(0, 2, 'fair_leak')
    plot_single_metric(1, 0, 'par')
    plot_single_metric(1, 1, 'eoo')
    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    plt.savefig(fname='{}beta_{}_{}.png'.format(PLOT_PATH, ds_name, fair_method), dpi=my_dpi, format='png')


@deprecated
def plot_beta_importance_by_train_acc(ds_name='nba', hyper_name='opt', all_runs=False, fair_method='Ad'):
    """
    Plot different metrics on y, and train_acc on x
    :param ds_name: dataset name
    :param hyper_name: hyperparameters name
    :param all_runs: if True, will use v234combined to show all finished runs,
                     if False, will only use runs with alpha = 1
    :param fair_method: 'Ad' or 'Fil', which fairness method to use for the plots
    :return:
    """
    comb = pd.read_feather('{}{}combined.ftr'.format(RESULTS_PATH, 'v234' if all_runs else ''))
    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name]
    comb.par = comb.par.apply(abs)
    comb.eoo = comb.eoo.apply(abs)
    comb.beta = comb.beta.apply(float)
    plt.clf()
    fig = plt.figure(figsize=(fig_width, 700 / my_dpi), dpi=my_dpi)
    fig.suptitle('beta effect on {}'.format(ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(2, 2, sharex=True)
    prop_cycle = plt.rcParams['axes.prop_cycle']
    std_colors = prop_cycle.by_key()['color']
    for i, model in enumerate(['Kipf', 'Sage', 'Gat']):
        comb_mod = comb.loc[comb.emb_net == '{}{}'.format(fair_method, model)].sort_values('test_acc')
        baseline_acc = list(comb.loc[comb.emb_net == model].test_acc)
        for subplot_y, subplot_x, metric in [(0, 0, 'fair_leak'), (0, 1, 'priv_leak'), (1, 0, 'par'), (1, 1, 'eoo')]:
            ax = axs[subplot_y, subplot_x]
            ax.scatter('test_acc', metric, data=comb_mod, label='{}{}'.format(fair_method, model),
                       color=std_colors[i], marker='.', alpha=0.5)
            ax.scatter(baseline_acc, list(comb.loc[comb.emb_net == model][metric]), color=std_colors[i], marker='x', s=100)
            # ax.set_title(metric)
            ax.set_xlabel('acc')
            ax.set_ylabel(metric)

    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower center', ncol=3)
    plt.tight_layout()
    plt.savefig(fname='{}acc_{}_{}_{}.png'.format(PLOT_PATH, 'all_ab' if all_runs else 'beta', ds_name, fair_method),
                dpi=my_dpi, format='png')


@deprecated
def plot_priv_of_fairness(ds_name='nba', priv_attrs=None, hyper_name='opt', fair_method='Ad'):
    """
    Plot different privacy leaks on x and different fairness on y
    :param hyper_name:
    :param fair_method: 'Ad' or 'Fil', which fairness method to use for the plots
    :return:
    """
    if priv_attrs is None:
        priv_attrs = ['AGE', 'player_weight', 'player_height']
    priv_leaks = [attr + '_leak' for attr in priv_attrs]
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.hyper_name == hyper_name].loc[comb.ds_name == ds_name]
    comb.par = comb.par.apply(abs)
    comb.eoo = comb.eoo.apply(abs)
    comb.beta = comb.beta.apply(float)
    plt.clf()
    fig = plt.figure(figsize=(fig_width, 700 / my_dpi), dpi=my_dpi)
    fig.suptitle('Privacy-Fairness trade-off'.format(), fontsize=fontsizes['title'])
    axs = fig.subplots(2, 3, sharex='col', sharey='row')
    prop_cycle = plt.rcParams['axes.prop_cycle']
    std_colors = prop_cycle.by_key()['color']
    for subplot_x, priv_leak in enumerate(priv_leaks):
        for i, model in enumerate(['Kipf', 'Sage', 'Gat']):
            comb_mod = comb.loc[comb.emb_net == '{}{}'.format(fair_method, model)].sort_values(priv_leak)
            baseline_priv = list(comb.loc[comb.emb_net == model][priv_leak])
            for subplot_y, metric in enumerate(['par', 'eoo']):
                ax = axs[subplot_y, subplot_x]
                ax.scatter(priv_leak, metric, data=comb_mod, label='{}{}'.format(fair_method, model), color=std_colors[i],
                           marker='.', alpha=0.5)
                ax.scatter(baseline_priv, list(comb.loc[comb.emb_net == model][metric]), color=std_colors[i],
                           marker='x', s=100)
        axs[0, subplot_x].set_title(priv_leak)
        axs[1, subplot_x].set_xlabel(priv_leak)
    axs[0, 0].set_ylabel('par')
    axs[1, 0].set_ylabel('eoo')
    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower center', ncol=3)
    plt.tight_layout()
    # plt.show()
    plt.savefig(fname='{}{}_{}_privacy_fairness_tradeoff.png'.format(PLOT_PATH, ds_name, fair_method),
                dpi=my_dpi, format='png')


@deprecated
def plot_5_privs_mia_fair(ds_name='nba', hyper_name='opt', alpha=1., fair_method='Ad'):
    """
    Plot up to 10 plots, with priv_leak on different attributes and different splits,
    Includes simple MIA and real MIA as well as par and eoo
    :param ds_name:
    :param hyper_name:
    :param alpha:
    :param fair_method: 'Ad' or 'Fil', which fairness method to use for the plots
    :return:
    """
    if ds_name == 'nba':
        priv_attrs = ['AGE', 'player_weight', 'player_height']
    else:
        priv_attrs = ['gender']
    comb = pd.read_feather('{}combined.ftr'.format(RESULTS_PATH))
    comb = comb.loc[comb.ds_name == ds_name].loc[comb.hyper_name == hyper_name].loc[
        (comb.alpha == alpha) | (~ comb.emb_net.str.contains(fair_method))]
    comb.par = comb.par.apply(abs)
    comb.eoo = comb.eoo.apply(abs)
    comb.beta = comb.beta.apply(float)
    plt.clf()
    fig = plt.figure(figsize=(fig_width * 2, 600 / my_dpi), dpi=my_dpi)
    fig.suptitle('priv and mia attacks on {}'.format(ds_name), fontsize=fontsizes['title'])
    axs = fig.subplots(2, 5, sharex=True)
    prop_cycle = plt.rcParams['axes.prop_cycle']
    std_colors = prop_cycle.by_key()['color']

    def plot_single_metric(subplot_y, subplot_x, metric):
        ax = axs[subplot_y, subplot_x]
        min_beta, max_beta = comb.loc[comb.alpha == alpha].beta.min(), comb.beta.max()
        for i, model in enumerate(['Kipf', 'Sage', 'Gat']):
            ax.plot('beta', metric, data=comb.loc[comb.emb_net == '{}{}'.format(fair_method, model)].sort_values('beta'),
                    label='{}{}'.format(fair_method, model), linestyle='-', color=std_colors[i])
            # plot the (unfair) baselines
            unfair_met = comb.loc[comb.emb_net == model][metric].item()
            ax.plot([min_beta, max_beta], [unfair_met] * 2, linestyle='--', color=std_colors[i])
        # make ticks
        # ax.tick_params('x', labelrotation=45)
        # ax.set_title(metric)
        ax.set_xlabel('beta')
        ax.set_ylabel(metric)
    plot_single_metric(0, 0, 'train_priv_leak')
    plot_single_metric(0, 1, 'test_priv_leak')
    for i in range(len(priv_attrs)):
        plot_single_metric(0, 2 + i, priv_attrs[i] + '_leak')
    plot_single_metric(1, 0, 'test_acc')
    plot_single_metric(1, 1, 'simple_mia')
    plot_single_metric(1, 2, 'mia_acc')
    plot_single_metric(1, 3, 'par')
    plot_single_metric(1, 4, 'eoo')
    handles, labels = axs[0, 0].get_legend_handles_labels()
    plt.figlegend(handles, labels, loc='lower right', ncol=1)
    plt.tight_layout()
    # plt.show()
    plt.savefig(fname='{}priv_mia_{}_{}.png'.format(PLOT_PATH, ds_name, fair_method), dpi=my_dpi, format='png')
